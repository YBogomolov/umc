import * as React from 'react';

import { ArrowRight, Download, RefreshCw, Sparkles } from 'lucide-react';
import { useDebouncedCallback } from 'use-debounce';

import { ImageGallery } from '@/components/ImageGallery';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectGroup, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Skeleton } from '@/components/ui/skeleton';
import { Textarea } from '@/components/ui/textarea';
import { downloadSingleImage } from '@/services/download';
import { generateId, generateImage } from '@/services/gemini';
import { useAppStore } from '@/store';
import type { GeminiModel, GeneratedImage, TabId } from '@/store/types';
import { GEMINI_MODELS } from '@/store/types';

interface GenerationScreenProps {
  tabId: TabId;
  title: string;
  promptPlaceholder: string;
  nextButtonLabel?: string;
  onNext?: () => void;
  autoGenerate?: boolean;
  referencePrompt?: string;
  referenceImageDataUrl?: string;
}

function GenerationScreen({
  tabId,
  title,
  promptPlaceholder,
  nextButtonLabel,
  onNext,
  autoGenerate,
  referencePrompt,
  referenceImageDataUrl,
}: GenerationScreenProps): React.ReactElement {
  const apiKey = useAppStore((s) => s.apiKey);
  const tabState = useAppStore((s) => s[tabId]);
  const addImage = useAppStore((s) => s.addImage);
  const selectImage = useAppStore((s) => s.selectImage);
  const setGenerating = useAppStore((s) => s.setGenerating);
  const getSelectedImage = useAppStore((s) => s.getSelectedImage);
  const geminiModel = useAppStore((s) => s.geminiModel);
  const setGeminiModel = useAppStore((s) => s.setGeminiModel);
  const currentSessionId = useAppStore((s) => s.currentSessionId);
  const sessions = useAppStore((s) => s.sessions);
  const updateSessionName = useAppStore((s) => s.updateSessionName);

  const selectedImage = getSelectedImage(tabId);
  const { images, isGenerating, selectedImageId } = tabState;

  // Get current session for name
  const currentSession = React.useMemo(
    () => sessions.find((s) => s.id === currentSessionId),
    [sessions, currentSessionId],
  );

  // Local state for name (for immediate typing feedback)
  const [localName, setLocalName] = React.useState(currentSession?.name ?? '');

  // Sync local name when session changes
  React.useEffect(() => {
    if (currentSession) {
      setLocalName(currentSession.name);
    }
  }, [currentSession]);

  // Debounced save to database
  const debouncedUpdateName = useDebouncedCallback((sessionId: string, name: string) => {
    void updateSessionName(sessionId, name);
  }, 500);

  // Handle name change - update local state immediately, debounce DB save
  const handleNameChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
    const newName = e.target.value;
    setLocalName(newName);
    if (currentSessionId) {
      debouncedUpdateName(currentSessionId, newName);
    }
  };

  // Derive initial prompt: selected image's prompt > referencePrompt > empty
  const [prompt, setPrompt] = React.useState(() => selectedImage?.prompt ?? referencePrompt ?? '');
  const [error, setError] = React.useState('');
  const hasAutoGenerated = React.useRef(false);

  // Sync prompt when selected image changes after mount
  const prevSelectedIdRef = React.useRef<string | null>(null);
  React.useEffect(() => {
    if (selectedImageId && selectedImageId !== prevSelectedIdRef.current) {
      prevSelectedIdRef.current = selectedImageId;
      const img = images.find((i) => i.id === selectedImageId);
      if (img) {
        setPrompt(img.prompt);
      }
    }
  }, [selectedImageId, images]);

  // Handle single image download
  const handleDownloadImage = (): void => {
    if (!selectedImage || !currentSession) return;
    const viewName = tabId === 'frontal' ? 'frontal' : tabId === 'back' ? 'back' : 'base';
    downloadSingleImage(selectedImage.dataUrl, currentSession.name, viewName);
  };

  const handleGenerate = React.useCallback(async (): Promise<void> => {
    if (!apiKey || !prompt.trim()) return;

    setError('');
    setGenerating(tabId, true);

    const result = await generateImage({
      apiKey,
      type: tabId,
      userPrompt: prompt.trim(),
      referenceImageDataUrl,
      modelName: geminiModel,
    });

    if (result.success && result.dataUrl) {
      const newImage: GeneratedImage = {
        id: generateId(),
        dataUrl: result.dataUrl,
        prompt: prompt.trim(),
        timestamp: Date.now(),
      };
      addImage(tabId, newImage);
    } else {
      setError(result.error ?? 'Generation failed');
    }

    setGenerating(tabId, false);
  }, [apiKey, prompt, tabId, setGenerating, addImage, referenceImageDataUrl, geminiModel]);

  // Auto-generate on mount if specified
  React.useEffect(() => {
    if (autoGenerate && referencePrompt && !hasAutoGenerated.current && images.length === 0) {
      hasAutoGenerated.current = true;
      void handleGenerate();
    }
  }, [autoGenerate, referencePrompt, images.length, handleGenerate]);

  return (
    <div className="flex h-full flex-col">
      <h2 className="mb-4 text-xl font-semibold">{title}</h2>

      {/* Image display area with download overlay */}
      <div className="group relative flex flex-1 items-center justify-center rounded-lg border bg-muted/30">
        {isGenerating ? (
          <Skeleton className="aspect-square w-full max-w-md" />
        ) : selectedImage ? (
          <>
            <img
              src={selectedImage.dataUrl}
              alt={`Generated ${title}`}
              className="max-h-[400px] max-w-full rounded object-contain"
            />
            {/* Download button on hover */}
            <button
              onClick={handleDownloadImage}
              className="absolute bottom-4 right-4 flex h-10 w-10 items-center justify-center rounded-full bg-background/90 text-foreground opacity-0 shadow-lg transition-opacity group-hover:opacity-100 hover:bg-background"
              title={`Download ${currentSession?.name ?? 'image'} - ${tabId}`}
            >
              <Download className="h-5 w-5" />
            </button>
          </>
        ) : (
          <div className="text-center text-muted-foreground">
            <Sparkles className="mx-auto mb-2 h-12 w-12 opacity-50" />
            <p>Enter a prompt and generate your {title.toLowerCase()}</p>
          </div>
        )}
      </div>

      {/* Image gallery for multiple generations */}
      <ImageGallery images={images} selectedId={selectedImageId} onSelect={(id) => selectImage(tabId, id)} />

      {/* Error display */}
      {error && <p className="mt-2 text-sm text-destructive">{error}</p>}

      {/* Miniature name input */}
      <div className="mt-4">
        <Input
          placeholder="Miniature name"
          value={localName}
          onChange={handleNameChange}
          disabled={!currentSession}
          className="w-full"
        />
      </div>

      {/* Model selector */}
      <div className="mt-2">
        <Select value={geminiModel} disabled={isGenerating} onValueChange={(m) => setGeminiModel(m as GeminiModel)}>
          <SelectTrigger className="w-full">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            <SelectGroup>
              {GEMINI_MODELS.map((m) => (
                <SelectItem key={m.value} value={m.value}>
                  {m.label}
                </SelectItem>
              ))}
            </SelectGroup>
          </SelectContent>
        </Select>
      </div>

      {/* Prompt input area */}
      <div className="mt-2 flex gap-2">
        <Textarea
          placeholder={promptPlaceholder}
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
          disabled={isGenerating}
          className="min-h-[80px] flex-1"
        />
        <div className="flex flex-col gap-2">
          <Button
            size="icon"
            onClick={() => void handleGenerate()}
            disabled={isGenerating || !prompt.trim()}
            title={images.length > 0 ? 'Regenerate' : 'Generate'}
          >
            {images.length > 0 ? <RefreshCw className="h-4 w-4" /> : <Sparkles className="h-4 w-4" />}
          </Button>
        </div>
      </div>

      {/* Navigation button */}
      <div className="mt-4 flex justify-end">
        {nextButtonLabel && onNext && (
          <Button onClick={onNext} disabled={!selectedImage}>
            {nextButtonLabel}
            <ArrowRight className="ml-2 h-4 w-4" />
          </Button>
        )}
      </div>
    </div>
  );
}

export { GenerationScreen };
