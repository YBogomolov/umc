import * as React from "react";
import { RefreshCw, Sparkles, ArrowRight, Download } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Textarea } from "@/components/ui/textarea";
import { Skeleton } from "@/components/ui/skeleton";
import { ImageGallery } from "@/components/ImageGallery";
import { useAppStore } from "@/store";
import { generateImage, generateId } from "@/services/gemini";
import type { TabId, GeneratedImage, GeminiModel } from "@/store/types";
import { GEMINI_MODELS } from "@/store/types";

interface GenerationScreenProps {
  tabId: TabId;
  title: string;
  promptPlaceholder: string;
  nextButtonLabel?: string;
  onNext?: () => void;
  showDownload?: boolean;
  onDownload?: () => void;
  autoGenerate?: boolean;
  referencePrompt?: string;
  referenceImageDataUrl?: string;
}

function GenerationScreen({
  tabId,
  title,
  promptPlaceholder,
  nextButtonLabel,
  onNext,
  showDownload,
  onDownload,
  autoGenerate,
  referencePrompt,
  referenceImageDataUrl,
}: GenerationScreenProps): React.ReactElement {
  const apiKey = useAppStore((s) => s.apiKey);
  const tabState = useAppStore((s) => s[tabId]);
  const addImage = useAppStore((s) => s.addImage);
  const selectImage = useAppStore((s) => s.selectImage);
  const setGenerating = useAppStore((s) => s.setGenerating);
  const getSelectedImage = useAppStore((s) => s.getSelectedImage);
  const geminiModel = useAppStore((s) => s.geminiModel);
  const setGeminiModel = useAppStore((s) => s.setGeminiModel);

  const selectedImage = getSelectedImage(tabId);
  const { images, isGenerating, selectedImageId } = tabState;

  // Derive initial prompt: selected image's prompt > referencePrompt > empty
  const [prompt, setPrompt] = React.useState(
    () => selectedImage?.prompt ?? referencePrompt ?? "",
  );
  const [error, setError] = React.useState("");
  const hasAutoGenerated = React.useRef(false);

  // Sync prompt when selected image changes after mount (e.g. gallery click, session load while mounted)
  const prevSelectedIdRef = React.useRef<string | null>(null);
  React.useEffect(() => {
    if (selectedImageId && selectedImageId !== prevSelectedIdRef.current) {
      prevSelectedIdRef.current = selectedImageId;
      const img = images.find((i) => i.id === selectedImageId);
      if (img) {
        setPrompt(img.prompt);
      }
    }
  }, [selectedImageId, images]);

  const handleGenerate = React.useCallback(async (): Promise<void> => {
    if (!apiKey || !prompt.trim()) return;

    setError("");
    setGenerating(tabId, true);

    const result = await generateImage({
      apiKey,
      type: tabId,
      userPrompt: prompt.trim(),
      referenceImageDataUrl,
      modelName: geminiModel,
    });

    if (result.success && result.dataUrl) {
      const newImage: GeneratedImage = {
        id: generateId(),
        dataUrl: result.dataUrl,
        prompt: prompt.trim(),
        timestamp: Date.now(),
      };
      addImage(tabId, newImage);
    } else {
      setError(result.error ?? "Generation failed");
    }

    setGenerating(tabId, false);
  }, [
    apiKey,
    prompt,
    tabId,
    setGenerating,
    addImage,
    referenceImageDataUrl,
    geminiModel,
  ]);

  // Auto-generate on mount if specified
  React.useEffect(() => {
    if (
      autoGenerate &&
      referencePrompt &&
      !hasAutoGenerated.current &&
      images.length === 0
    ) {
      hasAutoGenerated.current = true;
      handleGenerate();
    }
  }, [autoGenerate, referencePrompt, images.length, handleGenerate]);

  return (
    <div className="flex h-full flex-col">
      <h2 className="mb-4 text-xl font-semibold">{title}</h2>

      {/* Image display area */}
      <div className="flex flex-1 items-center justify-center rounded-lg border bg-muted/30">
        {isGenerating ? (
          <Skeleton className="aspect-square w-full max-w-md" />
        ) : selectedImage ? (
          <img
            src={selectedImage.dataUrl}
            alt={`Generated ${title}`}
            className="max-h-[400px] max-w-full rounded object-contain"
          />
        ) : (
          <div className="text-center text-muted-foreground">
            <Sparkles className="mx-auto mb-2 h-12 w-12 opacity-50" />
            <p>Enter a prompt and generate your {title.toLowerCase()}</p>
          </div>
        )}
      </div>

      {/* Image gallery for multiple generations */}
      <ImageGallery
        images={images}
        selectedId={selectedImageId}
        onSelect={(id) => selectImage(tabId, id)}
      />

      {/* Error display */}
      {error && <p className="mt-2 text-sm text-destructive">{error}</p>}

      {/* Model selector */}
      <div className="mt-4">
        <select
          value={geminiModel}
          onChange={(e) => setGeminiModel(e.target.value as GeminiModel)}
          disabled={isGenerating}
          className="w-full rounded-md border border-input bg-transparent px-3 py-1.5 text-sm shadow-sm focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50"
        >
          {GEMINI_MODELS.map((m) => (
            <option key={m.value} value={m.value}>
              {m.label}
            </option>
          ))}
        </select>
      </div>

      {/* Prompt input area */}
      <div className="mt-2 flex gap-2">
        <Textarea
          placeholder={promptPlaceholder}
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
          disabled={isGenerating}
          className="min-h-[80px] flex-1"
        />
        <div className="flex flex-col gap-2">
          <Button
            size="icon"
            onClick={handleGenerate}
            disabled={isGenerating || !prompt.trim()}
            title={images.length > 0 ? "Regenerate" : "Generate"}
          >
            {images.length > 0 ? (
              <RefreshCw className="h-4 w-4" />
            ) : (
              <Sparkles className="h-4 w-4" />
            )}
          </Button>
        </div>
      </div>

      {/* Navigation / Download buttons */}
      <div className="mt-4 flex justify-end gap-2">
        {nextButtonLabel && onNext && (
          <Button onClick={onNext} disabled={!selectedImage}>
            {nextButtonLabel}
            <ArrowRight className="ml-2 h-4 w-4" />
          </Button>
        )}
        {showDownload && onDownload && (
          <Button onClick={onDownload} disabled={!selectedImage}>
            <Download className="mr-2 h-4 w-4" />
            Download ZIP
          </Button>
        )}
      </div>
    </div>
  );
}

export { GenerationScreen };
