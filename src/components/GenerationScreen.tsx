import * as React from 'react';

import { ArrowRight, Download, Plus, RefreshCw, Sparkles, Upload, X } from 'lucide-react';
import { useDebouncedCallback } from 'use-debounce';

import { AttachmentChip } from '@/components/AttachmentChip';
import { ImageGallery } from '@/components/ImageGallery';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectGroup, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Skeleton } from '@/components/ui/skeleton';
import { Textarea } from '@/components/ui/textarea';
import { MiniId } from '@/services/db';
import { downloadSingleImage } from '@/services/download';
import { type Attachment, dataUrlToBase64, generateImage, generateImageId } from '@/services/gemini';
import { useAppStore } from '@/store';
import type { GeminiModel, GeneratedImage, TabId } from '@/store/types';
import { GEMINI_MODELS } from '@/store/types';

interface GenerationScreenProps {
  readonly tabId: TabId;
  readonly title: string;
  readonly promptPlaceholder: string;
  readonly nextButtonLabel?: string;
  readonly onNext?: () => void;
  readonly autoGenerate?: boolean;
  readonly referencePrompt?: string;
  readonly referenceImageDataUrl?: string;
  readonly allowUpload?: boolean;
  readonly onUpload?: (dataUrl: string) => void;
  readonly allowAttachments?: boolean;
}

function GenerationScreen({
  tabId,
  title,
  promptPlaceholder,
  nextButtonLabel,
  onNext,
  autoGenerate,
  referencePrompt,
  referenceImageDataUrl,
  allowUpload = false,
  onUpload,
  allowAttachments = false,
}: GenerationScreenProps): React.ReactElement {
  const apiKey = useAppStore((s) => s.apiKey);
  const tabState = useAppStore((s) => s[tabId]);
  const addImage = useAppStore((s) => s.addImage);
  const selectImage = useAppStore((s) => s.selectImage);
  const deleteImage = useAppStore((s) => s.deleteImage);
  const setGenerating = useAppStore((s) => s.setGenerating);
  const getSelectedImage = useAppStore((s) => s.getSelectedImage);
  const geminiModel = useAppStore((s) => s.geminiModel);
  const setGeminiModel = useAppStore((s) => s.setGeminiModel);
  const currentMiniId = useAppStore((s) => s.currentMiniId);
  const collections = useAppStore((s) => s.collections);
  const minis = useAppStore((s) => s.miniatures);
  const updateMiniName = useAppStore((s) => s.updateMiniName);

  const selectedImage = getSelectedImage(tabId);
  const { images, isGenerating, selectedImageId } = tabState;

  // Get current mini for name
  const currentMini = React.useMemo(() => minis.find((s) => s.id === currentMiniId), [minis, currentMiniId]);

  // Local state for name (for immediate typing feedback)
  const [localName, setLocalName] = React.useState(currentMini?.name ?? '');

  // Sync local name when mini changes
  React.useEffect(() => {
    if (currentMini) {
      setLocalName(currentMini.name);
    }
  }, [currentMini]);

  // Debounced save to database
  const debouncedUpdateName = useDebouncedCallback((miniId: MiniId, name: string) => {
    void updateMiniName(miniId, name);
  }, 500);

  // Handle name change - update local state immediately, debounce DB save
  const handleNameChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
    const newName = e.target.value;
    setLocalName(newName);
    if (currentMiniId) {
      debouncedUpdateName(currentMiniId, newName);
    }
  };

  // Derive initial prompt: selected image's prompt > referencePrompt > empty
  const [prompt, setPrompt] = React.useState(() => selectedImage?.prompt ?? referencePrompt ?? '');
  const [error, setError] = React.useState('');
  const hasAutoGenerated = React.useRef(false);

  // Upload state
  const [uploadedImage, setUploadedImage] = React.useState<string | null>(null);
  const [isDragging, setIsDragging] = React.useState(false);
  const fileInputRef = React.useRef<HTMLInputElement>(null);
  const isUploadingRef = React.useRef(false);

  // Attachments state
  const [attachments, setAttachments] = React.useState<Attachment[]>([]);
  const attachmentInputRef = React.useRef<HTMLInputElement>(null);

  // Sync prompt when selected image changes after mount
  const prevSelectedIdRef = React.useRef<string | null>(null);
  React.useEffect(() => {
    if (selectedImageId && selectedImageId !== prevSelectedIdRef.current) {
      prevSelectedIdRef.current = selectedImageId;
      const img = images.find((i) => i.id === selectedImageId);
      if (img) {
        setPrompt(img.prompt);
      }
    }
  }, [selectedImageId, images]);

  // Get the latest collection for default
  const latestCollection = React.useMemo(() => {
    if (collections.length === 0) return null;
    return collections.sort((a, b) => b.updatedAt - a.updatedAt)[0];
  }, [collections]);

  // Handle file upload - persists to database
  const handleFileUpload = (file: File): void => {
    // Prevent duplicate uploads
    if (isUploadingRef.current) {
      return;
    }
    isUploadingRef.current = true;

    if (!file.type.startsWith('image/')) {
      setError('Please upload an image file');
      isUploadingRef.current = false;
      return;
    }

    const reader = new FileReader();
    reader.onload = (e) => {
      const dataUrl = e.target?.result as string;
      if (dataUrl) {
        // Get current state from store (not closure) to check for duplicates
        const currentState = useAppStore.getState();
        const currentTabImages = currentState[tabId].images;

        // Check if this exact image already exists
        const imageExists = currentTabImages.some((img) => img.dataUrl === dataUrl);
        if (imageExists) {
          setError('This image has already been uploaded');
          isUploadingRef.current = false;
          return;
        }

        // If no mini exists, create one in the latest collection
        if (!currentState.currentMiniId) {
          const targetCollectionId = currentState.currentCollectionId ?? latestCollection?.id;
          if (targetCollectionId) {
            currentState.createNewMiniature(targetCollectionId);
          } else {
            setError('Please create a collection first');
            isUploadingRef.current = false;
            return;
          }
        }

        // Save uploaded image to database
        const uploadedImageData: GeneratedImage = {
          id: generateImageId(),
          dataUrl,
          prompt: `Uploaded: ${file.name}`,
          timestamp: Date.now(),
        };

        currentState.addImage(tabId, uploadedImageData);
        onUpload?.(dataUrl);
      }
      isUploadingRef.current = false;
    };
    reader.onerror = () => {
      setError('Failed to read image file');
      isUploadingRef.current = false;
    };
    reader.readAsDataURL(file);
  };

  // Click to upload
  const handleClickUpload = (): void => {
    fileInputRef.current?.click();
  };

  const handleFileInputChange = (e: React.ChangeEvent<HTMLInputElement>): void => {
    const file = e.target.files?.[0];
    if (file) {
      handleFileUpload(file);
    }
  };

  // Drag and drop handlers
  const handleDragEnter = (e: React.DragEvent): void => {
    e.preventDefault();
    e.stopPropagation();
    if (allowUpload && images.length === 0 && !uploadedImage) {
      setIsDragging(true);
    }
  };

  const handleDragLeave = (e: React.DragEvent): void => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);
  };

  const handleDragOver = (e: React.DragEvent): void => {
    e.preventDefault();
    e.stopPropagation();
  };

  const handleDrop = (e: React.DragEvent): void => {
    e.preventDefault();
    e.stopPropagation();
    setIsDragging(false);

    if (!allowUpload || images.length > 0 || uploadedImage) return;

    const file = e.dataTransfer.files[0];
    if (file) {
      handleFileUpload(file);
    }
  };

  // Clear uploaded image
  const handleClearUpload = (e: React.MouseEvent): void => {
    e.stopPropagation();
    setUploadedImage(null);
  };

  // Attachment handlers
  const handleAttachmentClick = (): void => {
    attachmentInputRef.current?.click();
  };

  const handleAttachmentAdd = (e: React.ChangeEvent<HTMLInputElement>): void => {
    const files = e.target.files;
    if (!files || files.length === 0) return;

    Array.from(files).forEach((file) => {
      if (!file.type.startsWith('image/')) {
        setError(`Invalid file type: ${file.name}. Only images are allowed.`);
        return;
      }

      if (file.size > 5 * 1024 * 1024) {
        setError(`File too large: ${file.name}. Maximum size is 5MB.`);
        return;
      }

      const reader = new FileReader();
      reader.onload = (event) => {
        const dataUrl = event.target?.result as string;
        if (dataUrl) {
          const { mimeType } = dataUrlToBase64(dataUrl);
          const newAttachment: Attachment = {
            id: generateImageId(),
            fileName: file.name,
            dataUrl,
            mimeType,
          };
          setAttachments((prev) => [...prev, newAttachment]);
        }
      };
      reader.onerror = () => {
        setError(`Failed to read file: ${file.name}`);
      };
      reader.readAsDataURL(file);
    });

    // Reset input so same file can be selected again
    e.target.value = '';
  };

  const handleAttachmentRemove = (id: string): void => {
    setAttachments((prev) => prev.filter((a) => a.id !== id));
  };

  // Handle single image download
  const handleDownloadImage = (): void => {
    if (!selectedImage || !currentMini) return;
    const viewName = tabId === 'frontal' ? 'frontal' : tabId === 'back' ? 'back' : 'base';
    downloadSingleImage(selectedImage.dataUrl, currentMini.name, viewName);
  };

  const handleGenerate = React.useCallback(async (): Promise<void> => {
    if (!apiKey || !prompt.trim()) return;

    setError('');
    setGenerating(tabId, true);

    // Use uploaded image as reference if available for frontal view
    const effectiveReferenceImage = uploadedImage ?? referenceImageDataUrl;

    const result = await generateImage({
      apiKey,
      type: tabId,
      userPrompt: prompt.trim(),
      referenceImageDataUrl: effectiveReferenceImage,
      modelName: geminiModel,
      attachments: attachments.length > 0 ? attachments : undefined,
    });

    if (result.success && result.dataUrl) {
      const newImage: GeneratedImage = {
        id: generateImageId(),
        dataUrl: result.dataUrl,
        prompt: prompt.trim(),
        timestamp: Date.now(),
      };
      addImage(tabId, newImage);
      // Clear uploaded image and attachments after successful generation
      setUploadedImage(null);
      setAttachments([]);
    } else {
      setError(result.error ?? 'Generation failed');
    }

    setGenerating(tabId, false);
  }, [apiKey, prompt, tabId, setGenerating, addImage, referenceImageDataUrl, geminiModel, uploadedImage, attachments]);

  // Auto-generate on mount if specified
  React.useEffect(() => {
    if (autoGenerate && referencePrompt && !hasAutoGenerated.current && images.length === 0) {
      hasAutoGenerated.current = true;
      void handleGenerate();
    }
  }, [autoGenerate, referencePrompt, images.length, handleGenerate]);

  // Determine what to show in the image area
  const showUploadZone = allowUpload && images.length === 0 && !uploadedImage;
  const showUploadedImage = uploadedImage && images.length === 0;

  return (
    <div className="flex h-full flex-col">
      <h2 className="mb-4 text-xl font-semibold">{title}</h2>

      {/* Image display area with download overlay */}
      <div
        className={`group relative flex flex-1 items-center justify-center rounded-lg border bg-muted/30 ${
          showUploadZone ? 'cursor-pointer' : ''
        } ${isDragging ? 'border-primary border-2 border-dashed bg-primary/5' : ''}`}
        onClick={showUploadZone ? handleClickUpload : undefined}
        onDragEnter={handleDragEnter}
        onDragLeave={handleDragLeave}
        onDragOver={handleDragOver}
        onDrop={handleDrop}
      >
        {/* Hidden file input */}
        <input ref={fileInputRef} type="file" accept="image/*" className="hidden" onChange={handleFileInputChange} />

        {isGenerating ? (
          <Skeleton className="aspect-square w-full max-w-md" />
        ) : selectedImage ? (
          <>
            <img
              src={selectedImage.dataUrl}
              alt={`Generated ${title}`}
              className="max-h-[400px] max-w-full rounded object-contain"
            />
            {/* Download button on hover */}
            <button
              onClick={handleDownloadImage}
              className="absolute bottom-4 right-4 flex h-10 w-10 items-center justify-center rounded-full bg-background/90 text-foreground opacity-0 shadow-lg transition-opacity group-hover:opacity-100 hover:bg-background"
              title={`Download ${currentMini?.name ?? 'image'} - ${tabId}`}
            >
              <Download className="h-5 w-5" />
            </button>
          </>
        ) : showUploadedImage ? (
          <div className="relative">
            <img
              src={uploadedImage}
              alt="Uploaded reference"
              className="max-h-[400px] max-w-full rounded object-contain"
            />
            {/* Clear upload button */}
            <button
              onClick={handleClearUpload}
              className="absolute -top-2 -right-2 flex h-8 w-8 items-center justify-center rounded-full bg-destructive text-destructive-foreground shadow-lg hover:bg-destructive/90"
              title="Remove uploaded image"
            >
              <X className="h-4 w-4" />
            </button>
            <p className="mt-2 text-center text-sm text-muted-foreground">Using as reference for generation</p>
          </div>
        ) : showUploadZone ? (
          <div className="flex flex-col items-center justify-center p-8 text-center text-muted-foreground">
            <Upload className="mx-auto mb-4 h-16 w-16 opacity-50" />
            <p className="mb-2 text-lg font-medium">
              {isDragging ? 'Drop image here' : 'Upload your front image or generate one from prompt'}
            </p>
            <p className="text-sm">Drag & drop or click to select</p>
            <p className="mt-2 text-xs opacity-70">Supports: JPG, PNG, WebP</p>
          </div>
        ) : (
          <div className="text-center text-muted-foreground">
            <Sparkles className="mx-auto mb-2 h-12 w-12 opacity-50" />
            <p>Enter a prompt and generate your {title.toLowerCase()}</p>
          </div>
        )}
      </div>

      {/* Image gallery for multiple generations */}
      <ImageGallery
        images={images}
        selectedId={selectedImageId}
        onSelect={(id) => selectImage(tabId, id)}
        onDelete={(id) => void deleteImage(tabId, id)}
      />

      {/* Error display */}
      {error && <p className="mt-2 text-sm text-destructive">{error}</p>}

      {/* Miniature name input */}
      <div className="mt-4">
        <Input
          placeholder="Miniature name"
          value={localName}
          onChange={handleNameChange}
          disabled={!currentMini}
          className="w-full"
        />
      </div>

      {/* Model selector */}
      <div className="mt-2">
        <Select value={geminiModel} disabled={isGenerating} onValueChange={(m) => setGeminiModel(m as GeminiModel)}>
          <SelectTrigger className="w-full">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            <SelectGroup>
              {GEMINI_MODELS.map((m) => (
                <SelectItem key={m.value} value={m.value}>
                  {m.label}
                </SelectItem>
              ))}
            </SelectGroup>
          </SelectContent>
        </Select>
      </div>

      {/* Prompt input area */}
      <div className="mt-2 flex gap-2">
        {allowAttachments && (
          <>
            <Button
              className="rounded-full"
              size="icon"
              variant="outline"
              disabled={isGenerating}
              onClick={handleAttachmentClick}
              title="Attach reference images"
            >
              <Plus className="h-4 w-4" />
            </Button>
            <input
              ref={attachmentInputRef}
              type="file"
              accept="image/*"
              multiple
              className="hidden"
              onChange={handleAttachmentAdd}
            />
          </>
        )}
        <Textarea
          placeholder={promptPlaceholder}
          value={prompt}
          onChange={(e) => setPrompt(e.target.value)}
          disabled={isGenerating}
          className="min-h-[80px] flex-1"
        />
        <div className="flex flex-col gap-2">
          <Button
            size="icon"
            onClick={() => void handleGenerate()}
            disabled={isGenerating || !prompt.trim()}
            title={images.length > 0 ? 'Regenerate' : 'Generate'}
          >
            {images.length > 0 ? <RefreshCw className="h-4 w-4" /> : <Sparkles className="h-4 w-4" />}
          </Button>
        </div>
      </div>

      {/* Attachment chips */}
      {allowAttachments && attachments.length > 0 && (
        <div className="mt-2 flex flex-wrap gap-2">
          {attachments.map((attachment) => (
            <AttachmentChip
              key={attachment.id}
              fileName={attachment.fileName}
              onRemove={() => handleAttachmentRemove(attachment.id)}
            />
          ))}
        </div>
      )}

      {/* Navigation button */}
      <div className="mt-4 flex justify-end">
        {nextButtonLabel && onNext && (
          <Button onClick={onNext} disabled={!selectedImage}>
            {nextButtonLabel}
            <ArrowRight className="ml-2 h-4 w-4" />
          </Button>
        )}
      </div>
    </div>
  );
}

export { GenerationScreen };
